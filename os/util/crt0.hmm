/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer
 *
 * Copyright (C) 2008-2020 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * util/crt0.hmm :crt0.s の外部インターフェイス
 *
 * 2020.08.16 : 各関数の使用方法を記述したコメントを追加
 * 2019.12.27 : 論理アドレスから物理アドレスの変換 _ItoP(), _AtoP() 追加
 * 2019.01.27 : I/O特権モード追加
 * 2018.01.27 : インクルードファイルの拡張子を .h から .hmm に変更
 * 2016.01.20 : _fp() を追加
 * 2016.01.19 : Ld32 と St32 を ld32 と st32 に変更
 * 2015.12.30 : St32 追加(重村)
 * 2015.09.02 : __AtoA 追加(重村)
 * 2014.05.07 : 村田開発開始
 * 2013.01.08 : ENINT, PRVLG 追加
 * 2012.12.26 : halt() 追加
 * 2012.09.20 : TaC-CPU V2 対応
 * 2012.03.02 : util.h から分離、新規作成
 *
 * $Id$
 */

#include <process.hmm>

//*****************************************************************************
// 特権命令など:
//   TaCの特殊な命令を呼び出す関数
//*****************************************************************************

/*-----------------------------------------------------------------------------
 *   名前    : setPri
 *   戻り値  : 操作前のflagレジスタの値
 *   引数    : flagにセットする値
 *   解説    : CPUのflagレジスタに値をセットする
 */
#define EI   0x0080                                 // 割込み許可
#define DI   0x0000                                 // 割込み不許可
#define KERN 0x0040                                 // カーネルモード
#define IPRV 0x0020                                 // I/O特権モード
#define USER 0x0000                                 // ユーザモード
public int setPri(int l);

/*-----------------------------------------------------------------------------
 *   名前    : in
 *   戻り値  : 入力した値
 *   引数    : int p  ポートのI/Oアドレス
 *   解説    : 16bit データをI/Oポートから入力する
 */
public int in(int p);

/*-----------------------------------------------------------------------------
 *   名前    : out
 *   戻り値  : なし
 *   引数    : int p  ポートのI/Oアドレス
 *             int v  出力する16bitデータ
 *   解説    : 16bit データをI/Oポートへ出力する
 */
public void out(int p, int v);

/*-----------------------------------------------------------------------------
 *   名前    : halt
 *   戻り値  : なし
 *   引数    : なし
 *   解説    : CPUを停止する（RUN を押しても再開しない）
 */
public void halt();

/*-----------------------------------------------------------------------------
 *   名前    : pause
 *   戻り値  : なし
 *   引数    : なし
 *   解説    : CPUを停止する（RUN を押すと戻ってくる）
 */
public void pause();

/*-----------------------------------------------------------------------------
 *   名前    : _fp
 *   戻り値  : FPの値
 *   引数    : なし
 *   解説    : CPUのFPレジスタの値を返す
 */
public int _fp();

//*****************************************************************************
// C-- サポート関数:
//   C-- に不足している機能を補う関数
//*****************************************************************************

/*-----------------------------------------------------------------------------
 *   名前    : _AtoI
 *   戻り値  : アドレスと同じ整数値
 *   引数    : アドレス
 *   解説    : C--の参照型を整数型に型変換する
 */
public int    _AtoI(void[] a);

/*-----------------------------------------------------------------------------
 *   名前    : _AtoA
 *   戻り値  : アドレス
 *   引数    : アドレス
 *   解説    : C--の参照型を参照型に型変換する
 */
public void[] _AtoA(void[] a);

/*-----------------------------------------------------------------------------
 *   名前    : _ItoA
 *   戻り値  : 整数値と同じアドレス
 *   引数    : 整数値
 *   解説    : C--の整数型を参照型に型変換する
 */
public void[] _ItoA(int a);

/*-----------------------------------------------------------------------------
 *   名前    : _addrAdd
 *   戻り値  : アドレス
 *   引数    : void[] a  アドレス
 *             int i     整数
 *   解説    : アドレスに整数を足して返す
 */
public void[] _addrAdd(void[] a, int i);

/*-----------------------------------------------------------------------------
 *   名前    : _uComp
 *   戻り値  : 大小比較の結果（1:>, 0:=, -1:<）
 *   引数    : int a, b  整数
 *   解説    : a, b を符号なし整数とみなして大小比較する
 */
public int    _uCmp(int a, int b);

/*-----------------------------------------------------------------------------
 *   名前    : _aComp
 *   戻り値  : 大小比較の結果（1:>, 0:=, -1:<）
 *   引数    : void[] a, b  アドレス
 *   解説    : a, b アドレスの大小比較をする
 */
public int    _aCmp(void[] a, void[] b);            // アドレスの大小比較

/*-----------------------------------------------------------------------------
 *   名前    : _args
 *   戻り値  : _argsを呼び出した関数の第２引数のアドレス
 *   引数    : なし
 *   解説    : printfのような可変引数の関数が使用する．
 *             int a = args();
 *             a[0]が第２引数，a[1]が第３引数．．．
 */
public void[] _args();

//*****************************************************************************
// 32bit 演算ルーチン：
//   32bit データは大きさ 2 の int 配列で表現する．
//   int[] dst が 32bit データを表現するとき，
//   dst[0]:上位16bit, dst[1]:下位16bitとなる．
//*****************************************************************************

/*-----------------------------------------------------------------------------
 *   名前    : _add32
 *   戻り値  : dstと同じアドレス
 *   引数    : int[] dst  32bit データ
 *             int[] src  32bit データ
 *   解説    : 32bit データ dst と src の和を計算する．（dst <- dst + src）
  */
public int[]  _add32(int[] dst, int[] src);

/*-----------------------------------------------------------------------------
 *   名前    : _sub32
 *   戻り値  : dstと同じアドレス
 *   引数    : int[] dst  32bit データ
 *             int[] src  32bit データ
 *   解説    : 32bit データ dst と src の差を計算する．（dst <- dst - src）
 */
public int[]  _sub32(int[] dst, int[] src);

/*-----------------------------------------------------------------------------
 *   名前    : _mul32
 *   戻り値  : dstと同じアドレス
 *   引数    : int[] dst  32bitデータ
 *             int src    16bitデータ
 *   解説    : 32bit データ dst と 16bit データ src の積を計算する．
 *             (dst <- dst * src)
 */
public int[]  _mul32(int[] dst, int src);

/*-----------------------------------------------------------------------------
 *   名前    : _div32
 *   戻り値  : dstと同じアドレス
 *   引数    : int[] dst  32bit データ
 *             int src    16bit データ
 *   解説    : 32bitデータ dst を 16bit データ src で割った商と余りを計算する．
 *             dst[0] <- dst / src  （商）
 *             dst[1] <- dst % src  （余）
 */
public int[]  _div32(int[] dst, int src);

/*-----------------------------------------------------------------------------
 *   名前    : _ld32（マクロ）
 *   引数    : int[] dst  32bit データ
 *             int ｈ     16bit データ
 *             int l      16bit データ
 *   解説    : ２つの 16bit データから一つの 32bit データを作る
 *             dst[0] <- h
 *             dst[1] <- l
 */
#define ld32(dst,h,l) ((dst)[0]=(h),(dst)[1]=(l))   // 32bit のデータのロード

/*-----------------------------------------------------------------------------
 *   名前    : _st32（マクロ）
 *   引数    : int ｈ     16bit データ
 *             int l      16bit データ
 *             int[] src  32bit データ
 *   解説    : 32bit データを２つの 16bit データにストアする
 *             h <- dst[0]
 *             l <- dst[1]
 */
#define st32(h,l,src) ((h)=(src)[0],(l)=(src)[1])   // 32bit のデータのストア

//*****************************************************************************
// 仮想アドレス，物理アドレス変換:
//   ユーザプロセスの仮想アドレスから，物理アドレスを計算する
//*****************************************************************************

/*-----------------------------------------------------------------------------
 *   名前    : _ItoP
 *   戻り値  : 物理アドレス
 *   引数    : int a 論理アドレス
 *             PCB pcb プロセス
 *   解説    : プロセスの論理アドレス(整数)を物理アドレスに変換する
 */
public void[] _ItoP(int a, PCB pcb);                // 論理=>物理アドレス変換

/*-----------------------------------------------------------------------------
 *   名前    : _AtoP
 *   戻り値  : 物理アドレス
 *   引数    : void[] a 論理アドレス
 *             PCB pcb プロセス
 *   解説    : プロセスの論理アドレスを物理アドレスに変換する
 */
public void[] _AtoP(void[] a, PCB pcb);             // 論理=>物理アドレス変換

// グローバル変数
public int _memSiz;                                 // 主記憶のサイズ
